import R from 'ramda';

export const getPartById = (state, id) => R.prop(id, state.parts);
export const getCategories = state => R.values(state.categories);

// R.path - чтобы наш код не упал, проверяет каждую переменную ownProps.id, ownProps.params на undefined перед тем как взять из нее child
export const getActiveCategoryId = ownProps => R.path(['params', 'id'], ownProps); // 1-й аргумент массив как вложен объект, 2-1 аргумент сам объект

export const getParts = (state, ownProps) => {
    const activeCategoryId = getActiveCategoryId(ownProps);
    const applySearch = item => R.compose( // проходимся по каждому товару и проверяем на вхождение подстроки в строке name
        R.contains(R.toLower(state.partsPage.search)),
        R.toLower,
        R.prop('name')
    )(item);

    const applyCategory = item => R.equals(
        activeCategoryId,
        R.prop('categoryId', item) // берем 'categoryId' из item и проверяем на равенство с activeCategoryId
    );

    const parts = R.compose(
        R.filter(applySearch), // фильтруем массив объектов товаров по поиску
        R.when(R.always(activeCategoryId), R.filter(applyCategory)), // R.when проверяет - когда есть activeCategoryId, мы выполняем R.filter(applyCategory)
        R.map(id => getPartById(state, id)) // получаем массив объектов товаров
    )(state.partsPage.ids);
    return parts;
};

export const getRenderedPartsLength = state => R.length(state.partsPage.ids); // возвращает длину массива

export const getTotalBasketCount = state => R.length(state.basket); // вернет длину массива

export const getTotalBasketPrice = state => {
  const totalPrice = R.compose(
      R.sum, // 3. суммируем все цены
      R.pluck('price'), // 2. массив строк цен
      R.map(id => getPartById(state, id)) // 1. получим массив объектов товаров которые в корзине
  )(state.basket);

    return totalPrice;
};

export const getBasketPartsWithCount = state => {
    const uniqueIds = R.uniq(state.basket); // только уникальные id без повторений
    const partCount = id => R.compose(
        R.length,
        R.filter(basketId => R.equals(id, basketId))
    )(state.basket);
    const partWithCount = part => R.assoc('count', partCount(part.id), part); // вернет новую part у которого будет новый count
    const parts = R.compose(
        R.map(partWithCount),
        R.map(id => getPartById(state, id))
    )(uniqueIds);
    return parts;
};